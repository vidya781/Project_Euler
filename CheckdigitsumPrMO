This is not a Project Euler problem per se, but rather a contest problem which I am attempting to solve computationally. The question asks one 
to find something:
How many positive integers less than 1000 have the property that the sum of the digits of each number is divisible by 7 and the number itself 
is divisible by 3?

Mathematical approach: The upper bound in this case is 1000 below which the numbers have to be found ( generated by a computer)
It's quite possible that we find a pattern within a small range first and then keep extending this idea to ranges that eventually touch the upper
bound. In that we keep drawing some parallels between the underlying mathematical idea and then extrapolating that to a computational process.

Lets take the range 1 to 100. 
We straightaway proceed from 7 onwards and note that the smallest 2 digit number that is divisible by 7 is 16 ( 1 + 6 )  but the second condition 
of being divisible by 3 fails.
25 is the next number but nevertheless it is not divisible by 3.

We would be well served by taking a filter based approach. 
1) Find out all the numbers that are divisible by 3 till the upper bound and collect them in a list.
2) Take the digit sum of all such numbers and then make a different list.
3) Check if each of these entries is 0 (mod 7) and increment the count if they are.

This is one of those cases where it may be computationally easier to solve the problem rather than work it out mathematically.
Nevertheless, we take the first interval of 2 digit numbers and start from 99, decrementing the units place 99, 89,79,69,59,49,39,29,19,09 and noting
the digit sums as 18,17,16,15,14,13,12,11,10, 9 and of which only one 59 is the candidate but fails to pass the other condition for divisibility by 3.
Hence ruled out. 
Next we take 98,88,78,68,58,48,38,28,18,08 ( by applying the same logic as before) The digit sums are 17,16,15,14,( ignore the rest as anything less
than 14 may not yield to the divisibility of 7 in the 2 digit range..we are not going all the way till 7 here). 68 is not divisible by 
3 , hence the second condition fails.

This teaches us one important thing in the filtering approach: the order of priorities : It is better we find the numbers in the range which are
divisible by 3 themselves first rather than calculating the digit sums first which may be computationally expensive first. ( Why? because one has to split the
number into its constituent digits and then the digit sum calculated and finally mod7 checked for , these are three distinct computational steps).
The process is much simplified if you take into account numbers which are filtered by the second condition first so the sample space gets reduced.

UB = 1000   # Upper bound is 1000
listdivbythree= []  # declaring an empty list 

def getnumbersdivby3(UB):
    for i in range(3,UB+1):
        if i % 3 == 0:             # checking for divisibility by 3
           listdivbythree.append(i)
    return listdivbythree     # returning the populated list for which the condition holds good
    
print (getnumbersdivby3(UB))

# Now the filtering process begins

digitsums = []   # declare an empty list that will hold the digit sums

def getdigitsums(listdivbythree):
    for entity in listdivbythree:
        digitsums.append(sum[int(d) for d in str(entity)]) # populating the digitsums list
    return digitsums
    
def getcountofrequired(digitsums):
    count = 0
    for item in digitsums:
         if item % 7 == 0:  # checking for divisibility by 7
             count+= 1
    return count        # returning the count variable to get the actual count

print(getcountofrequired(digitsums))

This sequential filtering process will ensure the process is computationally a lot faster. We could actually identify the time difference 
by coding the steps in a different way by using the timeit module. The difference will become significant even orders of magnitude more if 
the priority is taken into consideration.( This will depend on the UB as well.)

However we are yet to figure out an elegant math approach to the problem.

So we start from the reverse writing out numbers in the range (900,1000) and checking if the digit sums are 0 mod 7.

900, 903,906,909,....999
In this range 939,948,957,966,975,984 and 993 have digit sums of 21 which is 0 mod 7 and these numbers are also divisible themselves by 3. Hence 
we start collecting the count of numbers in this range R1 --{ 7}  # the count there is of the numbers satisfying the desired condition.

The aim was to find out if there are any patterns or symmetry appearing in this sea of numbers so that the process could be mathematically simplified
but there do not appear to be any periodicity occuring out here in order to forge a concrete conclusion.

So piecing out the ranges seems to be the best approach really until a significant insight comes through.

801,804,...898 and the count of numbers in this range is R2 --{ 5 }

We start the next range R3 from 702,705,....798 and the count is ---{ 5 }

At this point it seems there could be a pattern emerging but we need to hold on. R2 and R3 being 5 each respectively may be pure chance or randonmess 
operating.

600,603,609....699 and R4 yields ---{ 4 } 

On to R5 then 501,504,507,510,...597 ----{ 3 }. At this point all we can say is that there is no apparent pattern or symmetry but this
needs to be explored further. But one thing is clear. In a range spanning 33 numbers or so, the second half of the range has the numbers that
meet the desired condition.

In R6 which spans the range 402,405,408,..497 the count is R6----> {2} > A computer wouldnt have cognition of this fact but brutely make the count. The discerning mind comes in here.[ An interesing 
side track: Can a computer be endowed with discretion and discernment here?]


In R7, from 300,303,306,...399 There is only one number R7----> { 1 }

Can we expect some more numbers in this range from 201,204,207,....300. No numbers n this range have a digit sum of 14 or 21. Hence R8 ---{0} the empty set

For generating R9 ( if any ) we consider the penultimate range 102,105,108,....201
R9---{0} No numbers have a digit sum which mod 7 = 0.

R10 3,6,9,....99 No numbers have a digit sum which mod7 = 0 , hence R10----{ 0 }

Sigma R(i) i ranging from 10 to 1 = 0 + 0 + 0 + 1 + 2 + 3 + 4 + 5 + 5 + 7 = 27 

Thus by a manual calculation observing some trends like the digit sum not summing upto a unit ( which mod 7 would have to be zero), one can quickly
calculate the number of such numbers given a specific Upper Bound ( UB). In this case it is 27. 

Some additional points where the human mind is capable of a discerning search is the lack of such numbers in the early ranges and the number of such numbers
increasing slowly and in some cases being identical ( two times 5 obtained).

The above was still a BF manual method.

The elegant method is as follows:

Let the number be abc. We have a + b + c = 7k ( sum of digits being divisible by 7)
Also, the number is divisible by 3 , a + b + c = 3m
So a + b + c is divisible by 21
Now each of a,b and c can take values from 0 to 9 and hence a + b + c >= 0 but <= 27 and combining both these constraints,
we are led to believe that a + b + c = 21 only.

So lets formulate a table

Possible values of a,b,c       Permutations
-----------------------       --------------
9    9    3                     3!/2! = 3

9    8    4                     3! = 6   ( no repetition of digits here)

9    7    5                     3! = 6  ( no repetition here as well)

9    6    6                     3!/2! = 3

8    8    5                     3!/2! = 3

8    7    6                     3!/2! = 3

7    7    7                      3!/3! = 1 

Hence the total number of such numbers = 1 + 3 + 3 + 3 + 6 + 6 + 3 = 28.This method is more convincing than the BF manual approach and
is less error prone. It seems plausible that one number has been missed out in the manual approach but the point was to inherently draw parallels
between a computational procedure and a manual thought process approaching the same problem.
The parts where the computer would spend a lot of time ( bottleneck time scales) and a human would find it very easy and vice versa.
So AI procedures must always be used with a human touch to it for faster evolution. A combinatoric procedure works best really.
 
 
The actual tested code is as follows:

import time
start = time.process_time()

Upper_Bound = 1000

L = list(range(1,Upper_Bound+1))  # generating the list which will be worked upon

def getdigits(L):
    """This function serves to generate the individual lists of digits in the range specified"""
    D = []    # have a separate list to hold the digit lists
    for item in L:
        D.append([int(d)for d in str(item)])
    return D
 
func1 = getdigits(L)
       
# At this point we have the entire list in terms of its individual digits

# Now we need to filter out based on 2 conditions: divisibility by 3 as well
# divisibility by 7, that is divisibility by 21 
# So essentially what we have to do is loop through the entire list
# 

def getcount(func1):
    """This function serves to generate the count of the numbers that we wanted, satifying the 
    given condition, in this case the sum of the digits being divisible by 7 and the number itself
    being divisible by 3, in short the sum of the digits being divisible by 21"""
    C = []
    for item in func1:
        if sum(item) % 21 == 0:
            C.append(item)
    return C

print(len(getcount(func1)))  # we just need to know how many numbers in the given range satisfy this property

end = time.process_time()
print(end - start)

The time here that elapsed for the execution of this program is 0.00258 seconds.

Now in order to analyse the time complexity and the efficiency aspects, it's worth segregating the functions and then testing
it out.

import time
start = time.process_time()

Upper_Bound = 1000
L = list(range(1,Upper_Bound+1)) # generating the list which will be worked upon

def getdivisiblebythree(L):
    list_div_by_three = []  # hold all numbers in the list which are divisible by three
    for i in L:
        if i%3 == 0:
            list_div_by_three.append(i)
    return list_div_by_three   

func1 = getdivisiblebythree(L)

### At this point we have numbers in the range which are themselves divisble by three
### We need to filter this list by testing for digit sums divisible by 7

def getindividuallists(func1):
    L = []  
    for item in func1:
        L.append([int(d) for d in str(item)])
    return L

func2 = getindividuallists(func1)

def getdivisiblebyseven(func2):
    D = []
    for entity in func2:
        D.append(sum(entity))
    return D

func3 = getdivisiblebyseven(func2)

def getcountfinal(func3):
    count = 0
    for j in func3:
        if j%7 == 0:
            count+= 1
    return count

func4 = getcountfinal(func3)
print(func4)

end = time.process_time()
print(end - start)

The above piece of code took 0.001735999 seconds which is faster than the previous code where two conditions were combined into
one. This is an indication that segregating functions might be beneficial in the long run.In the above case, what was essentially
done was to get the numbers divisible by 3 in the range, then testing for divisibility of digit sums of these by 7.

It might be worth getting the digit sums first divisible by 7 and finally filtering out these and testing for divisibilty of the
numbers by 3 finally.

import time
start = time.process_time()

Upper_bound = 1000
L = list(range(1,Upper_bound + 1))  # generating the list which will be worked on

def generatelistdigits(L):
    D = []  ### this list will hold the lists of digits
    for item in L:
        D.append([int(d) for d in str(item)])
    return D

func1 = generatelistdigits(L) ### At this point we have the list of lists

def generatesums(func1):  ###
    Sums = []
    for lists in func1:
        Sums.append(sum(lists))
    return Sums

func2 = generatesums(func1)   #### At this point we have the sum of the individual lists

def filterfordivbyseven(func2):
    sevens = []
    for j in func2:
        if j % 7 == 0:
            sevens.append(j)
    return sevens           ### tested for divisibility by 7 at this point and collected

func3 = filterfordivbyseven(func2)

def filterfordivbythree(func3):
    count = 0
    for num in func3:
        if num % 3 == 0:
            count += 1
    return count          ### Individual numbers further filtered for divisibility by 3

func4 = filterfordivbythree(func3)
print(func4)

end = time.process_time()
print(end - start)     # Time of execution noted
    
In the final case, we have the time of execution as 0.003248 seconds. So this process of generating the sums first , then filtering
for divisibility for 7, followed by sequential filtration for divisibilty of the individual numbers by three takes the longest
time on preliminary investigation.

Equivalent Java Code is as follows:

We straightaway proceed to check for divisibility by 21. 

import java.io.*;

class checkfordivby21{
    // function to count the numbers divisible by M in a given range
    static int countDivisibles(int A, int B, int M)
       {
          // Variable to store the counter
           int counter = 0;
           
           // Running a loop from A to B and check if a number is divisible by M
           
           for(int i = A; i <= B; i++)
              if( i % M == 0)
                 counter++;
           return counter;
        }
        //driver program
        
        public static void main(String[] args)
         {
            // A and B define the range, M the dividend
            int A = 1, B = 1000, M = 21;
            System.out.println(countDivisibles(A,B,M);
         }
    }
   
   // Alternative Java program which is faster
   
   import java.io.*;
   
   class divby21{
     // Function to count the numbers divisible by M in a given range
     
     static int countDivisibles2(int A, int B, int M)
     {
        // Add 1 explicitly as A is divisible by M
        
        if(A % M == 0)
           return (B/M) - (A/M) + 1;
           
       // A is not divisible by M
      return(B/M) - (A/M);
     }
     
     // driver program
     public static void main(String[] args)
     {
        // A and B define the range, M is the dividend
        int A = 1, B = 1000, M = 21;
        
        // Printing the result
        System.out.println(countDivisibles2(A,B,M));
     }
  }
  
  
   
   
         
 
 
