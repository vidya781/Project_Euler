This is not a Project Euler problem per se, but rather a contest problem which I am attempting to solve computationally. The question asks one 
to find something:
How many positive integers less than 1000 have the property that the sum of the digits of each number is divisible by 7 and the number itself 
is divisible by 3?

Mathematical approach: The upper bound in this case is 1000 below which the numbers have to be found ( generated by a computer)
It's quite possible that we find a pattern within a small range first and then keep extending this idea to ranges that eventually touch the upper
bound. In that we keep drawing some parallels between the underlying mathematical idea and then extrapolating that to a computational process.

Lets take the range 1 to 100. 
We straightaway proceed from 7 onwards and note that the smallest 2 digit number that is divisible by 7 is 16 ( 1 + 6 )  but the second condition 
of being divisible by 3 fails.
25 is the next number but nevertheless it is not divisible by 3.

We would be well served by taking a filter based approach. 
1) Find out all the numbers that are divisible by 3 till the upper bound and collect them in a list.
2) Take the digit sum of all such numbers and then make a different list.
3) Check if each of these entries is 0 ( mod 7) and increment the count if they are.

This is one of those cases where it may be computationally easier to solve the problem rather than work it out mathematically.
Nevertheless, we take the first interval of 2 digit numbers and start from 99, decrementing the units place 99, 89,79,69,59,49,39,29,19,09 and noting
the digit sums as 18,17,16,15,14,13,12,11,10, 9 and of which only one 59 is the candidate but fails to pass the other condition for divisibility by 3.
Hence ruled out. 
Next we take 98,88,78,68,58,48,38,28,18,08 ( by applying the same logic as before) The digit sums are 17,16,15,14,( ignore the rest as anything less
than 14 may not yield to the divisibility of 7 in the 2 digit range..we are not goinga ll the way till 7 here). 68 is not divisible by 
3 , hence the second condition fails.

This teaches us one important thing in the filtering approach: the order of priorities : It is better we find the numbers in the range which are
divisible by 3 themselves first rather than calculating the digit sums first which may be computationally expensive first. ( Why? because one has to split the
number into its constituent digits and then the digit sum calculated and finally mod7 checked for , these are three distinct computational steps).
The process is much simplified if you take into account numbers which are filtered by the second condition first so the sample space gets reduced.

UB = 1000   # Upper bound is 1000
listdivbythree= []  # declaring an empty list 

def getnumbersdivby3(UB):
    for i in range(3,UB+1):
        if i % 3 == 0:
           listdivbythree.append(i)
    return listdivbythree     # returning the populated list for which the condition holds good
    
print (getnumbersdivby3(UB))

# Now the filtering process begins

digitsums = []   # declare an empty list that will hold the digit sums

